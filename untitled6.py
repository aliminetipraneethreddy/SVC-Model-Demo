# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13y6bCkSjjfp6bHGyYD6ka9_Bn_ViEf6n
"""

#from google.colab import drive
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns



path = 'loan_approved (1).csv'

df=pd.read_csv(path)
df.head()

df.isna().sum()

df.fillna(df['LoanAmount'].mean(),inplace=True)

df.fillna(df['Gender'].mode(),inplace=True)
df.fillna(df['Married'].mode(),inplace=True)
df.isna().sum()

from sklearn.preprocessing import LabelEncoder

#df.isna().sum()
# The previous fillna in LZTK29HOGF2x replaced NaNs in object columns with float values,
# leading to mixed-type columns. df.dropna(inplace=True) is a no-op here as all NaNs were filled.
label_encoders={}
for col in df.select_dtypes(include=['object']).columns:
  le=LabelEncoder()
  # Convert the column to string type to handle potential mixed types introduced by fillna
  df[col] = df[col].astype(str)
  df[col]=le.fit_transform(df[col])
  label_encoders[col]=le

#make data X with attributes Applicant income,Loan amount,Credit history,self employed
X = df[['ApplicantIncome', 'LoanAmount', 'Credit_History', 'Self_Employed']]
y=df[['Loan_Status (Approved)']]

from sklearn.model_selection import train_test_split
X_train,X_test,y_train,y_test=train_test_split(X, y, test_size=0.2,random_state=42)

from sklearn.preprocessing import StandardScaler
scaler=StandardScaler()
X_train=scaler.fit_transform(X_train)
X_test=scaler.transform(X_test)

from sklearn.svm import SVC
svm_linear=SVC(kernel='linear',C=1)
svm_linear.fit(X_train,y_train)
y_pred_linear=svm_linear.predict(X_test)

from sklearn.metrics import accuracy_score,classification_report,confusion_matrix
acc=accuracy_score(y_test,y_pred_linear)
acc

#confusion matrix
cm=confusion_matrix(y_test,y_pred_linear)
cm

svm_poly=SVC(kernel='poly',degree=3,C=1)
svm_poly.fit(X_train,y_train)
y_pred_poly=svm_poly.predict(X_test)

from sklearn.metrics import accuracy_score,classification_report,confusion_matrix
acc=accuracy_score(y_test,y_pred_poly)
acc

#confusion matrix
cm_poly=confusion_matrix(y_test,y_pred_poly)
cm_poly

svm_rbf=SVC(kernel='poly',degree=3,gamma='scale')
svm_rbf.fit(X_train,y_train)
y_pred_rbf=svm_rbf.predict(X_test)

from sklearn.metrics import accuracy_score,classification_report,confusion_matrix
acc=accuracy_score(y_test,y_pred_rbf)
acc

#confusion matrix
cm_rbf=confusion_matrix(y_test,y_pred_rbf)
cm_rbf

mean_credit_history = X_train[:, 2].mean()
mean_self_employed = X_train[:, 3].mean()

# Create meshgrid for 'ApplicantIncome' and 'LoanAmount'
x_min, x_max = X_test[:, 0].min() - 1, X_test[:, 0].max() + 1
y_min, y_max = X_test[:, 1].min() - 1, X_test[:, 1].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.02), np.arange(y_min, y_max, 0.02))

print("Mean Credit_History (scaled):", mean_credit_history)
print("Mean Self_Employed (scaled):", mean_self_employed)
print("Meshgrid created for ApplicantIncome and LoanAmount.")

import matplotlib.pyplot as plt

# Construct the full input array for prediction
# The first two columns are from the meshgrid, and the last two are constant means
Z_input = np.c_[xx.ravel(), yy.ravel(),
                np.full(xx.ravel().shape, mean_credit_history),
                np.full(xx.ravel().shape, mean_self_employed)]

# Predict class for each point in the meshgrid using svm_linear
Z = svm_linear.predict(Z_input)
Z = Z.reshape(xx.shape)

# Plot the decision boundary
plt.figure(figsize=(10, 7))
plt.contourf(xx, yy, Z, alpha=0.8, cmap=plt.cm.coolwarm)

# Plot the test data points
# Ensure y_test is a 1D array for coloring
y_test_1d = y_test.values.ravel()
plt.scatter(X_test[:, 0], X_test[:, 1], c=y_test_1d, cmap=plt.cm.coolwarm, edgecolors='k', marker='o', s=50)

# Add labels and title
plt.xlabel('ApplicantIncome (Scaled)')
plt.ylabel('LoanAmount (Scaled)')
plt.title('Linear SVM Decision Boundary (ApplicantIncome vs LoanAmount)')
plt.colorbar(label='Predicted Class')
plt.show()

print("Linear SVM decision boundary plotted successfully.")

import matplotlib.pyplot as plt

# Construct the full input array for prediction
# The first two columns are from the meshgrid, and the last two are constant means
Z_input_poly = np.c_[xx.ravel(), yy.ravel(),
                     np.full(xx.ravel().shape, mean_credit_history),
                     np.full(xx.ravel().shape, mean_self_employed)]

# Predict class for each point in the meshgrid using svm_poly
Z_poly = svm_poly.predict(Z_input_poly)
Z_poly = Z_poly.reshape(xx.shape)

# Plot the decision boundary for svm_poly
plt.figure(figsize=(10, 7))
plt.contourf(xx, yy, Z_poly, alpha=0.8, cmap=plt.cm.coolwarm)

# Plot the test data points
y_test_1d = y_test.values.ravel()
plt.scatter(X_test[:, 0], X_test[:, 1], c=y_test_1d, cmap=plt.cm.coolwarm, edgecolors='k', marker='o', s=50)

# Add labels and title
plt.xlabel('ApplicantIncome (Scaled)')
plt.ylabel('LoanAmount (Scaled)')
plt.title('Polynomial SVM Decision Boundary (ApplicantIncome vs LoanAmount)')
plt.colorbar(label='Predicted Class')
plt.show()

print("Polynomial SVM decision boundary plotted successfully.")

import matplotlib.pyplot as plt

# Construct the full input array for prediction
# The first two columns are from the meshgrid, and the last two are constant means
Z_input_rbf = np.c_[xx.ravel(), yy.ravel(),
                     np.full(xx.ravel().shape, mean_credit_history),
                     np.full(xx.ravel().shape, mean_self_employed)]

# Predict class for each point in the meshgrid using svm_rbf
Z_rbf = svm_rbf.predict(Z_input_rbf)
Z_rbf = Z_rbf.reshape(xx.shape)

# Plot the decision boundary for svm_rbf
plt.figure(figsize=(10, 7))
plt.contourf(xx, yy, Z_rbf, alpha=0.8, cmap=plt.cm.coolwarm)

# Plot the test data points
y_test_1d = y_test.values.ravel()
plt.scatter(X_test[:, 0], X_test[:, 1], c=y_test_1d, cmap=plt.cm.coolwarm, edgecolors='k', marker='o', s=50)

# Add labels and title
plt.xlabel('ApplicantIncome (Scaled)')
plt.ylabel('LoanAmount (Scaled)')
plt.title('RBF SVM Decision Boundary (ApplicantIncome vs LoanAmount)')
plt.colorbar(label='Predicted Class')
plt.show()

print("RBF SVM decision boundary plotted successfully.")



# Assuming the confusion matrix is structured as:
# [[TN, FP],
#  [FN, TP]]
# where 0 is 'N' (rejected/risky) and 1 is 'Y' (approved/eligible)

# --- Linear SVM ----
print("\n--- Linear SVM Misclassifications ---")
# False Negatives (Eligible customers rejected): True label Y (1), Predicted N (0)
fn_linear = cm_linear[1, 0]
# False Positives (Risky customers approved): True label N (0), Predicted Y (1)
fp_linear = cm_linear[0, 1]

print(f"Eligible customers rejected (False Negatives): {fn_linear}")
print(f"Risky customers approved (False Positives): {fp_linear}")

# --- Polynomial SVM ---
print("\n--- Polynomial SVM Misclassifications ---")
# False Negatives (Eligible customers rejected): True label Y (1), Predicted N (0)
fn_poly = cm_poly[1, 0]
# False Positives (Risky customers approved): True label N (0), Predicted Y (1)
fp_poly = cm_poly[0, 1]

print(f"Eligible customers rejected (False Negatives): {fn_poly}")
print(f"Risky customers approved (False Positives): {fp_poly}")

# --- RBF SVM (Note: configured as poly) ---
print("\n--- RBF SVM (Configured as Poly) Misclassifications ---")
# False Negatives (Eligible customers rejected): True label Y (1), Predicted N (0)
fn_rbf = cm_rbf[1, 0]
# False Positives (Risky customers approved): True label N (0), Predicted Y (1)
fp_rbf = cm_rbf[0, 1]

print(f"Eligible customers rejected (False Negatives): {fn_rbf}")
print(f"Risky customers approved (False Positives): {fp_rbf}")

"""## Plot Confusion Matrix for Best SVM Model

### Subtask:
Generate and display a heatmap of the confusion matrix for the Polynomial SVM model (cm_poly), including true labels and predicted labels, to visualize its performance.

**Reasoning**:
To visualize the performance of the Polynomial SVM model, I will generate and display a heatmap of the `cm_poly` confusion matrix, including true and predicted labels, as requested by the subtask instructions.
"""

import seaborn as sns
import matplotlib.pyplot as plt

plt.figure(figsize=(8, 6))
sns.heatmap(cm_poly, annot=True, fmt='d', cmap='Blues')
plt.xlabel('Predicted Labels')
plt.ylabel('True Labels')
plt.title('Confusion Matrix for Polynomial SVM (Best Model)')
plt.show()



import numpy as np
import ipywidgets as widgets
from IPython.display import display, HTML, clear_output

# Assuming svm_linear, svm_poly, svm_rbf, scaler, label_encoders are already defined from previous cells

# Map model names to actual trained models
models = {
    "Linear SVM": svm_linear,
    "Polynomial SVM": svm_poly,
    "RBF SVM (configured as Poly)": svm_rbf # Keeping this name as it was configured this way
}

# Get the LabelEncoder for 'Loan_Status (Approved)' to interpret predictions
loan_status_encoder = label_encoders['Loan_Status (Approved)']
# Assuming 'N' is 0 and 'Y' is 1 based on previous output ['N', 'Y']
loan_status_mapping = {0: 'N', 1: 'Y'}
if len(loan_status_encoder.classes_) == 2:
    if loan_status_encoder.classes_[0] == 'N':
        loan_status_mapping = {0: 'N', 1: 'Y'}
    else: # Assuming classes_[0] == 'Y'
        loan_status_mapping = {0: 'Y', 1: 'N'}

# Define user input widgets
model_choice = widgets.Dropdown(
    options=list(models.keys()),
    description='Select Model:',
    disabled=False,
)

applicant_income_input = widgets.IntText(
    value=5000, # Example value
    description='Applicant Income:',
    disabled=False
)

loan_amount_input = widgets.FloatText(
    value=150.0, # Example value
    description='Loan Amount:',
    disabled=False
)

# For Credit_History, offer 'Yes'/'No' and map to its encoded form
ch_encoder = label_encoders.get('Credit_History')
ch_options_mapping = {}
if ch_encoder:
    try:
        ch_options_mapping['Yes'] = ch_encoder.transform([str(1.0)])[0]
    except ValueError:
        pass
    try:
        ch_options_mapping['No'] = ch_encoder.transform([str(0.0)])[0]
    except ValueError:
        pass

if 'Yes' in ch_options_mapping and 'No' in ch_options_mapping:
    credit_history_input = widgets.RadioButtons(
        options=[(f'Yes (encoded: {ch_options_mapping["Yes"]})', ch_options_mapping["Yes"]),
                 (f'No (encoded: {ch_options_mapping["No"]})', ch_options_mapping["No"])],
        description='Credit History:',
        disabled=False
    )
else: # Fallback if specific encoded values not reliably found
    credit_history_input = widgets.RadioButtons(
        options=[('Yes (1.0)', 1.0), ('No (0.0)', 0.0)],
        description='Credit History (assumed numerical):',
        disabled=False
    )

# For Self_Employed, offer 'Yes'/'No' and map to its encoded form
se_encoder = label_encoders.get('Self_Employed')
se_options_mapping = {}
if se_encoder:
    try:
        se_options_mapping['Yes'] = se_encoder.transform(['Yes'])[0]
    except ValueError:
        pass
    try:
        se_options_mapping['No'] = se_encoder.transform(['No'])[0]
    except ValueError:
        pass

if 'Yes' in se_options_mapping and 'No' in se_options_mapping:
    self_employed_input = widgets.RadioButtons(
        options=[(f'Yes (encoded: {se_options_mapping["Yes"]})', se_options_mapping["Yes"]),
                 (f'No (encoded: {se_options_mapping["No"]})', se_options_mapping["No"])],
        description='Self Employed:',
        disabled=False
    )
else: # Fallback if specific encoded values not reliably found
    self_employed_input = widgets.RadioButtons(
        options=[('Yes (1)', 1), ('No (0)', 0)],
        description='Self Employed (assumed numerical):',
        disabled=False
    )


predict_button = widgets.Button(description="Predict Loan Status")
output_area = widgets.Output()

def predict_loan_status(model_name, applicant_income, loan_amount, credit_history_val, self_employed_val):
    selected_model = models.get(model_name)
    if not selected_model:
        print("Invalid model selected.")
        return

    # Create input array in the order expected by the scaler and model
    input_data = np.array([[applicant_income, loan_amount, credit_history_val, self_employed_val]])

    # Scale the input data using the same scaler fitted on X_train
    scaled_input_data = scaler.transform(input_data)

    # Make prediction
    prediction = selected_model.predict(scaled_input_data)

    # Inverse transform the prediction to get original label 'Y' or 'N'
    predicted_status = loan_status_mapping.get(int(prediction[0]), 'Unknown')

    print(f"\n--- Prediction for {model_name} ---")
    print(f"Based on the provided details, the loan status is predicted as: {predicted_status}")
    if predicted_status == 'Y':
        print("Loan Recommended: Approve")
    elif predicted_status == 'N':
        print("Loan Recommended: Reject")
    else:
        print("Could not determine loan recommendation.")


def on_predict_button_clicked(b):
    with output_area:
        clear_output(wait=True)
        try:
            predict_loan_status(
                model_choice.value,
                applicant_income_input.value,
                loan_amount_input.value,
                credit_history_input.value,
                self_employed_input.value
            )
        except Exception as e:
            print(f"An error occurred during prediction: {e}")

predict_button.on_click(on_predict_button_clicked)

# Display widgets
print("Enter loan applicant details to get a prediction:")
display(model_choice, applicant_income_input, loan_amount_input, credit_history_input, self_employed_input, predict_button, output_area)

print("\nNote: For 'Credit History' and 'Self Employed', the displayed numbers next to Yes/No are the values after LabelEncoding which the model expects. Please ensure these correspond to your intended input.")